Index: launcher.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import global_vars\r\n\r\nDEBUG = False\r\n\r\nglobal_vars.set_var('level', 'locations/' + input('level: '))\r\nglobal_vars.set_var(\r\n    'plants', [\r\n        'plants:walnut',\r\n        'plants:fumeshroom',\r\n        'plants:gravebuster',\r\n        'plants:sunshroom',\r\n        'plants:scaredyshroom',\r\n        'plants:puffshroom'\r\n    ]\r\n)\r\nglobal_vars.set_var('DEBUG', DEBUG)\r\n\r\nimport main\r\n\r\ntry:\r\n    if global_vars.get_var(\"complete\"):\r\n        print(\"You beat: \" + global_vars.get_var(\"level\").split(\":\")[1] + \"!\")\r\nexcept KeyError:\r\n    pass
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- launcher.py	(revision 1e716dbc123e95b1d68c78e817188db88446aa38)
+++ launcher.py	(date 1621305503474)
@@ -5,12 +5,13 @@
 global_vars.set_var('level', 'locations/' + input('level: '))
 global_vars.set_var(
     'plants', [
-        'plants:walnut',
         'plants:fumeshroom',
-        'plants:gravebuster',
-        'plants:sunshroom',
+        'plants:puffshroom',
         'plants:scaredyshroom',
-        'plants:puffshroom'
+        'plants:sunshroom',
+        'plants:gravebuster',
+        'plants:walnut'
+
     ]
 )
 global_vars.set_var('DEBUG', DEBUG)
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nimport os\r\nos.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = \"hide\"\r\nimport pygame as pg\r\nimport json\r\nimport random\r\nimport global_vars\r\nimport math\r\n\r\nSCALE = 64\r\nFPS = 60\r\nSCREEN_HEIGHT = 11 * SCALE\r\nSCREEN_WIDTH = 11 * SCALE\r\nVOLUME = 1.2\r\nLANES = 7\r\nDEBUG = global_vars.get_var('DEBUG')\r\n\r\npg.font.init()\r\npg.mixer.init()\r\nwindow = pg.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pg.SCALED)\r\npg.display.set_caption('PVZ clone')\r\npg.display.set_icon(pg.image.load('data/plants/repeater/sprite0.png').convert_alpha())\r\nclock = pg.time.Clock()\r\n\r\n\r\ndef get_data(full_id):\r\n\r\n    with open('data/' + \"/\".join(full_id.split(':')) + '/data.json', 'r') as data_file:\r\n        return json.load(data_file)\r\n\r\n\r\ndef get_image(full_id):\r\n    return str('data/' + \"/\".join(full_id.split(':')) + '.png')\r\n\r\n\r\ndef get_sound(full_id):\r\n    return str('data/' + \"/\".join(full_id.split(':')) + '.mp3')\r\n\r\n\r\nclass Drawable:\r\n    def __init__(self, image_source, location, drawable_id):\r\n        self.x, self.y = location\r\n        self.location = location\r\n        self.image = pg.image.load(image_source).convert_alpha()\r\n        self.id = drawable_id\r\n\r\n    def draw(self, surface):\r\n        surface.blit(self.image, self.location)\r\n\r\n\r\nclass Bullet:\r\n    def __init__(self, x, y, projectile_id, damage=None, angle=0):\r\n        self.x = x\r\n        self.y = y\r\n        self.data = get_data(projectile_id)\r\n        self.speed = self.data['projectile_speed']\r\n        self.change_y = math.sin((angle*180/math.pi))*self.speed\r\n        self.change_x = math.cos((angle*180/math.pi))*self.speed\r\n        if damage is not None:\r\n            self.damage = damage\r\n        else:\r\n            self.damage = self.data['damage']\r\n        self.lane = self.y / SCALE\r\n        self.sprite = pg.image.load(self.data['sprite']).convert_alpha()\r\n        try:\r\n            self.hit_sound = Sound(self.data['hit_sound'])\r\n            Sound(self.data['fire_sound']).play()\r\n        except ValueError:\r\n            pass\r\n\r\n    def tick(self, frame_number):\r\n        if self.x > SCREEN_WIDTH:\r\n            projectiles.remove(self)\r\n        if frame_number % 2 == 0:\r\n            self.x += self.change_x\r\n            self.y += self.change_y\r\n            for zombie in zombies:\r\n                if zombie.lane == self.lane:\r\n                    if pg.Rect(zombie.x, zombie.y, SCALE, SCALE).colliderect(pg.Rect(self.x, self.y, SCALE, SCALE)):\r\n                        zombie.shield -= self.damage\r\n                        try:\r\n                            self.hit_sound.play()\r\n                        except NameError:\r\n                            pass\r\n                        try:\r\n                            projectiles.remove(self)\r\n                        except ValueError:\r\n                            pass\r\n            if self.x > SCREEN_WIDTH:\r\n                projectiles.remove(self)\r\n\r\n    def draw(self, surface):\r\n        surface.blit(self.sprite, (self.x, self.y))\r\n\r\n\r\nclass Fume:\r\n    def __init__(self, x, y, projectile_id, damage=None, length=4, angle=0):\r\n        self.x = x\r\n        self.y = y\r\n        self.data = get_data(projectile_id)\r\n        if damage is None:\r\n            self.damage = self.data['damage']\r\n        else:\r\n            self.damage = damage\r\n        self.lane = self.y / SCALE\r\n        self.length = length\r\n        self.sprite = pg.image.load(self.data['sprite']).convert_alpha()\r\n\r\n        try:\r\n            self.hit_sound = Sound(self.data['hit_sound'])\r\n            Sound(self.data['fire_sound']).play()\r\n        except ValueError:\r\n            pass\r\n        self.start_time = time.time()\r\n        for zombie in zombies:\r\n            if zombie.lane == self.lane:\r\n                if pg.Rect(zombie.x, zombie.y, SCALE, SCALE).colliderect(pg.Rect(self.x, self.y, self.length*SCALE, SCALE)):\r\n                    zombie.health -= self.damage\r\n                    try:\r\n                        self.hit_sound.play()\r\n                    except NameError:\r\n                        pass\r\n\r\n    def tick(self, frame_number):\r\n        if time.time() - self.start_time > 1.5:\r\n            projectiles.remove(self)\r\n\r\n    def draw(self, surface):\r\n        for i in range(self.length):\r\n            surface.blit(self.sprite, (self.x + i * SCALE, self.y))\r\n\r\n\r\nclass Zombie:\r\n    def __init__(self, zombie_id, x, y, frame_num, wave=False):\r\n        self.id = zombie_id\r\n        self.x = x\r\n        self.y = y\r\n        self.start_time = frame_num\r\n        self.lane = self.y / SCALE\r\n        self.wave = wave\r\n\r\n        self.data = get_data(zombie_id)\r\n\r\n        self.health = self.data['health']\r\n        self.sprite = pg.image.load(get_data(self.id)['sprite']).convert_alpha()\r\n        self.speed = self.data['speed']\r\n        self.eat = None\r\n        self.damage = self.data['damage']\r\n        self.state = 0\r\n        self.cooldown = 0\r\n        try:\r\n            self.shield = self.data['shield']\r\n        except KeyError:\r\n            self.shield = 0\r\n\r\n    def tick(self, frame_number):\r\n        try:\r\n            if len(self.data['tick']) > 1:\r\n                exec(\"\\n\".join(self.data['tick']))\r\n            else:\r\n                exec(self.data['tick'])\r\n        except KeyError:\r\n            self.default_tick(frame_number)\r\n\r\n    def default_tick(self, frame_number):\r\n        global run\r\n        if self.shield < 0:\r\n            self.health -= abs(self.shield)\r\n            self.shield = 0\r\n        if frame_number % 3 == 0 and self.eat is None:\r\n            self.x -= self.speed\r\n            if self.x < 0:\r\n                print('lost')\r\n                if not DEBUG:\r\n                    run = False\r\n                zombies.remove(self)\r\n        if (frame_number - self.start_time) % 50 == 0 and self.eat is not None:\r\n            self.eat.health -= self.damage\r\n            Sound('sounds:eat').play()\r\n            if self.eat.health <= 0:\r\n                try:\r\n                    plants.remove(self.eat)\r\n                    self.eat.tile.occupied = False\r\n                except ValueError:\r\n                    self.eat.tile.occupied = False\r\n            if self.eat not in plants:\r\n                self.eat = None\r\n\r\n        if self.health <= 0:\r\n            zombies.remove(self)\r\n        for plant in plants:\r\n            if pg.Rect(plant.x, plant.y, SCALE, SCALE).colliderect(\r\n                    pg.Rect(self.x, self.y, SCALE, SCALE * 2)) and self.lane == plant.lane:\r\n                self.eat = plant\r\n\r\n    def attack(self):\r\n        if type(self.data['attack']) == list:\r\n            exec(str(\"\\n\".join(self.data['attack'])))\r\n        else:\r\n            exec(str(self.data['attack']))\r\n\r\n    def draw(self, surface):\r\n        surface.blit(self.sprite, (int(self.x), int(self.y) - SCALE))\r\n\r\n\r\nclass Plant:\r\n    def __init__(self, plant_id, connected_tile, frame_num):\r\n        self.id = plant_id\r\n        self.tile = connected_tile\r\n        self.x = self.tile.x\r\n        self.y = self.tile.y\r\n        self.start_time = frame_num\r\n        self.lane = self.y / SCALE\r\n        self.time_starting = time.time()\r\n\r\n        self.data = get_data(plant_id)\r\n\r\n        self.health = self.data['health']\r\n        self.sprite = pg.image.load(get_data(self.id)['sprite']).convert_alpha()\r\n        self.cost = self.data['cost']\r\n        self.state = 0\r\n        self.queue = []\r\n        self.return_value = None\r\n\r\n    def tick(self, frame_number):\r\n        try:\r\n            if len(self.data['tick']) > 1:\r\n                exec(\"\\n\".join(self.data['tick']))\r\n            else:\r\n                exec(self.data['tick'])\r\n        except KeyError:\r\n            self.default_tick(frame_number)\r\n\r\n    def default_tick(self, frame_number):\r\n        try:\r\n            if int(time.time()) - int(self.time_starting) != 0 and (int(time.time()) - int(self.time_starting)) %\\\r\n                    (self.data['attack_speed']) == 0 and frame_number % 60 == 0:\r\n                for i in range(self.data['burst']):\r\n                    self.queue.append(self.attack)\r\n            if frame_number % 8 == 0:\r\n                if len(self.queue) > 0:\r\n                    self.queue[0]()\r\n                    self.queue.remove(self.queue[0])\r\n        except KeyError:\r\n            pass\r\n\r\n    def requirements(self):\r\n        self.return_value = None\r\n        try:\r\n            if len(self.data['requirements']) > 1:\r\n                exec(\"\\n\".join(self.data['requirements']))\r\n            else:\r\n                exec(self.data['requirements'])\r\n        except KeyError:\r\n            return self.default_requirements()\r\n        if self.return_value is not None:\r\n            return self.return_value\r\n        else:\r\n            return False\r\n\r\n    def default_requirements(self):\r\n        for background_object in background_objects:\r\n            if pg.Rect(background_object.x, background_object.y, SCALE, SCALE).colliderect(self.x, self.y, SCALE, SCALE)\\\r\n                    and background_object.id != 'grave' and self.tile.id not in [\"roof\", \"water\"]:\r\n                return False\r\n        return True\r\n\r\n    def attack(self):\r\n        if type(self.data['attack']) == list:\r\n            exec(str(\"\\n\".join(self.data['attack'])))\r\n        else:\r\n            exec(str(self.data['attack']))\r\n\r\n    def draw(self, surface):\r\n        surface.blit(self.sprite, (int(self.x), int(self.y)))\r\n\r\n\r\nclass Sun:\r\n    def __init__(self, x, y, value=25, sunflower=False,):\r\n        self.x = x\r\n        if not sunflower:\r\n            self.dest_y = y\r\n            self.y = 0\r\n        else:\r\n            self.y = y\r\n            self.dest_y = y\r\n\r\n        self.sprite = pg.image.load('data/other/sun/sun.png').convert_alpha()\r\n        self.timer = 0\r\n        self.value = value\r\n        self.speed = 1\r\n\r\n    def draw(self, surface):\r\n        surface.blit(self.sprite, (int(self.x), int(self.y)))\r\n\r\n    def tick(self, frame_number):\r\n        if self.y < self.dest_y:\r\n            self.y += self.speed\r\n        self.timer += 1\r\n        if self.timer > 10 * FPS:\r\n            suns.remove(self)\r\n\r\n\r\nclass Sound:\r\n    def __init__(self, sound_id):\r\n        self.source = get_sound(sound_id)\r\n        self.sound = pg.mixer.Sound(self.source)\r\n        self.sound.set_volume(VOLUME)\r\n\r\n    def play(self):\r\n        self.sound.play()\r\n\r\n\r\nclass Tile:\r\n    def __init__(self, x, y, version):\r\n        self.x = x\r\n        self.y = y\r\n        self.occupied = False\r\n        self.species = random.randint(1, 4)\r\n        self.version = version\r\n        # this is a placeholder that will change later to reflect the level such as pool or roof\r\n        self.id = 'grass'\r\n        self.sprite = pg.image.load(location_data['tiles'] + '/' + \"tile\" + str(self.version) + '-' + str(self.species) + '.png')\r\n\r\n    def draw(self, surface):\r\n        surface.blit(self.sprite, (int(self.x), int(self.y)))\r\n\r\n\r\nclass BottomBar:\r\n    def __init__(self, items):\r\n        self.items = []\r\n        self.x = 0\r\n        self.y = 9 * SCALE\r\n        self.sprite = pg.image.load('data/other/menus/bottom_bar.png').convert()\r\n        self.selected_sprite = pg.image.load('data/other/menus/selected.png').convert_alpha()\r\n        self.selected = None\r\n\r\n        for item in items:\r\n            self.items.append(\r\n                {\r\n                    'x': 1.25 * SCALE + items.index(item) * SCALE * 1.5,\r\n                    'y': 9.5 * SCALE,\r\n                    'sprite': pg.image.load(get_data(item)['display_sprite']).convert_alpha(),\r\n                    'cost': get_data(item)['cost'],\r\n                    'id': item,\r\n                    'cooldown': get_data(item)['starting_cooldown'],\r\n                },\r\n            )\r\n\r\n    def tick(self, frame_num):\r\n        for item in self.items:\r\n            item['cooldown'] -= 1 / FPS\r\n            if item['cooldown'] < 0:\r\n                item['cooldown'] = 0\r\n\r\n    def draw(self, surface):\r\n        surface.blit(self.sprite, (self.x, self.y))\r\n        for item in self.items:\r\n            surface.blit(item['sprite'], (item['x'], item['y']))\r\n            if item['cost'] > sun_count:\r\n                color = (255, 0, 0)\r\n            else:\r\n                color = (0, 0, 0)\r\n            surface.blit(font.render(str(item['cost']), False, color), (item['x'], item['y'] + SCALE))\r\n            if item['cooldown'] > 0:\r\n                overlay = pg.Surface((SCALE, SCALE))\r\n                overlay.set_alpha(100)\r\n                overlay.fill((255, 0, 0))\r\n                surface.blit(overlay, (item['x'], item['y']))\r\n            if self.selected == item['id']:\r\n                surface.blit(self.selected_sprite, (item['x'], item['y']))\r\n        surface.blit(font.render('Sun: ' + str(sun_count), False, (0, 0, 0)), (0, 9 * SCALE))\r\n\r\n\r\nrun = True\r\ntiles = []\r\nplants = []\r\nfont = pg.font.SysFont('Comic Sans MS', 16, bold=True)\r\nsun_count = 50\r\nsuns = []\r\nprojectiles = []\r\nselected_plant = None\r\nchosen_plants = global_vars.get_var('plants')\r\nbottom_bar = BottomBar(chosen_plants)\r\nzombies = []\r\ncooldown_start_time = time.time()\r\ncurrent_level = global_vars.get_var('level')\r\nzombie_queue = []\r\nwave_mode = False\r\nwaves = get_data(current_level)['waves']\r\nwave_time = None\r\nlevel_data = get_data(current_level)\r\ngame_start = False\r\ndrawables = []\r\nlocation_data = get_data('/'.join(current_level.split(':')[:-1]))\r\ncooldown = location_data['cooldown']\r\nchance = location_data['chance']\r\nsun_rate = location_data['sun_rate']\r\nbackground_objects = []\r\n\r\n\r\ndef tick(frame_number):\r\n    global cooldown_start_time\r\n    global chance\r\n    global level_data\r\n    global wave_mode\r\n    global wave_time\r\n    global cooldown\r\n    global game_start\r\n    global run\r\n    try:\r\n        if len(location_data['tick']) > 1:\r\n            exec(\"\\n\".join(location_data['tick']))\r\n        else:\r\n            exec(location_data['tick'])\r\n    except KeyError:\r\n        pass\r\n    if random.randint(0, sun_rate) == 1:\r\n        suns.append(Sun(random.randint(0, 10 * SCALE), random.randint(SCALE, 8 * SCALE)))\r\n    for sun in suns:\r\n        sun.tick(frame_number)\r\n    for plant in plants:\r\n        plant.tick(frame_number)\r\n    for zombie in zombies:\r\n        zombie.tick(frame_number)\r\n    for projectile in projectiles:\r\n        projectile.tick(frame_number)\r\n    bottom_bar.tick(frame_number)\r\n\r\n    wave_zombie_count = 0\r\n\r\n    for zombie in zombies:\r\n        if zombie.wave:\r\n            wave_zombie_count += 1\r\n\r\n    if time.time() - cooldown_start_time > cooldown and not wave_mode and len(waves) > 0:\r\n        if len(zombie_queue) == 0 and wave_zombie_count == 0:\r\n            print(\"Start Roam\")\r\n            pg.mixer.fadeout(4)\r\n            Sound('sounds:main_theme').play()\r\n            roam_zombies = level_data['roam_zombies']\r\n            for key in list(roam_zombies.keys()):\r\n                for i in range(roam_zombies[key]):\r\n                    zombie_queue.append(key)\r\n\r\n        if len(zombie_queue) > 0:\r\n            rate = int(chance - 5*(time.time() - cooldown_start_time))\r\n            if rate < 100:\r\n                rate = 100\r\n            if random.randint(0, rate) == 1:\r\n                zombie_choice = random.choice(zombie_queue)\r\n                zombies.append(Zombie(zombie_choice, 10*SCALE, random.randint(1, 8)*SCALE, frame))\r\n                zombie_queue.remove(zombie_choice)\r\n        if len(zombie_queue) == 0 and wave_zombie_count == 0 and wave_time is None:\r\n            count = 0\r\n            for drawable in drawables:\r\n                if drawable.id == 'wave':\r\n                    count += 1\r\n            if count == 0:\r\n                drawables.append(Drawable(\r\n                    image_source='data/other/menus/wave.png',\r\n                    location=(0, 0),\r\n                    drawable_id='wave',\r\n                 )\r\n                )\r\n\r\n                wave_mode = True\r\n                wave_time = time.time()\r\n                pg.mixer.fadeout(4)\r\n\r\n    if len(waves) == 0 and wave_zombie_count == 0:\r\n        run = False\r\n        global_vars.set_var(\"complete\", True)\r\n\r\n    if wave_mode and time.time() - wave_time > 5:\r\n        Sound('sounds:wave_theme').play()\r\n        for drawable in drawables:\r\n            if drawable.id == 'wave':\r\n                drawables.remove(drawable)\r\n        print(\"Start Wave\")\r\n        wave = waves[0]\r\n        for key in list(wave.keys()):\r\n            for i in range(wave[key]):\r\n                zombie_queue.append(key)\r\n        try:\r\n            if len(location_data['wave']) > 1:\r\n                exec(\"\\n\".join(location_data['wave']))\r\n            else:\r\n                exec(location_data['wave'])\r\n        except KeyError:\r\n            pass\r\n        while len(zombie_queue) > 0:\r\n            zombie_choice = random.choice(zombie_queue)\r\n            zombies.append(Zombie(zombie_choice, 10 * SCALE, random.randint(1, 8) * SCALE, frame, wave=True))\r\n            zombie_queue.remove(zombie_choice)\r\n        waves.remove(wave)\r\n        wave_mode = False\r\n        cooldown = 5\r\n        cooldown_start_time = time.time()\r\n        wave_time = None\r\n        chance = 800\r\n\r\n\r\ndef draw_screen(surface, frame_number):\r\n    surface.fill(location_data['background'])\r\n\r\n    for tile in tiles:\r\n        tile.draw(surface)\r\n    for background_object in background_objects:\r\n        background_object.draw(surface)\r\n    for plant in plants:\r\n        plant.draw(surface)\r\n    for i in range(1, LANES+2):\r\n        for zombie in zombies:\r\n            if zombie.lane == i:\r\n                zombie.draw(surface)\r\n    for projectile in projectiles:\r\n        projectile.draw(surface)\r\n    for sun in suns:\r\n        sun.draw(surface)\r\n    for drawable in drawables:\r\n        drawable.draw(surface)\r\n\r\n    bottom_bar.draw(surface)\r\n\r\n    pg.display.update()\r\n\r\n\r\nfor x in range(0, 11):\r\n    for y in range(1, 9):\r\n        if x % 2 == 0:\r\n            if y % 2 == 0:\r\n                tiles.append(Tile(x * SCALE, y * SCALE, 1))\r\n            else:\r\n                tiles.append(Tile(x * SCALE, y * SCALE, 2))\r\n        else:\r\n            if y % 2 == 0:\r\n                tiles.append(Tile(x * SCALE, y * SCALE, 2))\r\n            else:\r\n                tiles.append(Tile(x * SCALE, y * SCALE, 1))\r\n\r\nframe = 1\r\n\r\ntry:\r\n    if len(location_data['start']) > 1:\r\n        exec(\"\\n\".join(location_data['start']))\r\n    else:\r\n        exec(location_data['start'])\r\nexcept KeyError:\r\n    pass\r\n\r\n\r\nwhile run:\r\n    clock.tick(FPS)\r\n    for event in pg.event.get():\r\n        if event.type == pg.QUIT:\r\n            run = False\r\n\r\n        if event.type == pg.KEYDOWN and DEBUG:\r\n            if event.key == pg.K_z:\r\n                zombies.append(Zombie('zombies:basic', 10*SCALE, random.randint(1, 8)*SCALE, frame))\r\n            if event.key == pg.K_s:\r\n                sun_count += 500\r\n            if event.key == pg.K_c:\r\n                for item in bottom_bar.items:\r\n                    item['cooldown'] = 0\r\n            if event.key == pg.K_v:\r\n                run = False\r\n                global_vars.set_var(\"complete\", True)\r\n\r\n    if pg.mouse.get_pressed()[0]:\r\n        if selected_plant is not None:\r\n            for item in bottom_bar.items:\r\n                if item['id'] == selected_plant and item['cooldown'] <= 0 and sun_count >= get_data(selected_plant)['cost']:\r\n                    for tile in tiles:\r\n                        if not tile.occupied and pg.Rect(tile.x, tile.y, SCALE, SCALE).collidepoint(pg.mouse.get_pos()):\r\n                            if Plant(selected_plant, tile, frame_num=frame).requirements():\r\n                                tile.occupied = True\r\n                                plants.append(Plant(selected_plant, tile, frame_num=frame))\r\n                                sun_count -= get_data(selected_plant)['cost']\r\n                                for item in bottom_bar.items:\r\n                                    if item['id'] == selected_plant:\r\n                                        item['cooldown'] = get_data(item['id'])['cooldown']\r\n                                        selected_plant = None\r\n                                        bottom_bar.selected = None\r\n                                Sound('sounds:plant').play()\r\n\r\n        for sun in suns:\r\n            if pg.Rect(sun.x, sun.y, SCALE / 2, SCALE / 2).collidepoint(pg.mouse.get_pos()):\r\n                sun_count += sun.value\r\n                suns.remove(sun)\r\n                Sound('sounds:pickup').play()\r\n\r\n        for item in bottom_bar.items:\r\n            if pg.Rect(item['x'], item['y'], SCALE, SCALE).collidepoint(pg.mouse.get_pos()) and selected_plant != item['id']:\r\n                    selected_plant = item['id']\r\n                    bottom_bar.selected = item['id']\r\n                    Sound('sounds:select').play()\r\n\r\n    if pg.mouse.get_pressed()[2]:\r\n        for plant in plants:\r\n            if pg.Rect(plant.x, plant.y, SCALE, SCALE).collidepoint(pg.mouse.get_pos()):\r\n                plant.tile.occupied = False\r\n                plants.remove(plant)\r\n                Sound('sounds:remove').play()\r\n\r\n        for item in bottom_bar.items:\r\n            if pg.Rect(item['x'], item['y'], SCALE, SCALE).collidepoint(pg.mouse.get_pos()) and selected_plant == item['id']:\r\n                selected_plant = None\r\n                bottom_bar.selected = None\r\n\r\n    frame += 1\r\n\r\n    if frame > FPS * 60:\r\n        frame = 1\r\n\r\n    tick(frame)\r\n\r\n    draw_screen(window, frame)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- main.py	(revision 1e716dbc123e95b1d68c78e817188db88446aa38)
+++ main.py	(date 1621304724361)
@@ -17,8 +17,9 @@
 
 pg.font.init()
 pg.mixer.init()
+pg.init()
 window = pg.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pg.SCALED)
-pg.display.set_caption('PVZ clone')
+pg.display.set_caption('PVZ version -1.0')
 pg.display.set_icon(pg.image.load('data/plants/repeater/sprite0.png').convert_alpha())
 clock = pg.time.Clock()
 
@@ -436,7 +437,7 @@
     if time.time() - cooldown_start_time > cooldown and not wave_mode and len(waves) > 0:
         if len(zombie_queue) == 0 and wave_zombie_count == 0:
             print("Start Roam")
-            pg.mixer.fadeout(4)
+            pg.mixer.fadeout(2000)
             Sound('sounds:main_theme').play()
             roam_zombies = level_data['roam_zombies']
             for key in list(roam_zombies.keys()):
@@ -445,8 +446,8 @@
 
         if len(zombie_queue) > 0:
             rate = int(chance - 5*(time.time() - cooldown_start_time))
-            if rate < 100:
-                rate = 100
+            if rate < 150:
+                rate = 150
             if random.randint(0, rate) == 1:
                 zombie_choice = random.choice(zombie_queue)
                 zombies.append(Zombie(zombie_choice, 10*SCALE, random.randint(1, 8)*SCALE, frame))
@@ -466,7 +467,7 @@
 
                 wave_mode = True
                 wave_time = time.time()
-                pg.mixer.fadeout(4)
+                pg.mixer.fadeout(2000)
 
     if len(waves) == 0 and wave_zombie_count == 0:
         run = False
Index: data/locations/day/3/data.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n  \"waves\": [\r\n    {\r\n      \"zombies:conehead\": 20,\r\n      \"zombies:basic\": 25\r\n    },\r\n    {\r\n      \"zombies:buckethead\": 5,\r\n      \"zombies:conehead\": 20,\r\n      \"zombies:basic\": 20,\r\n      \"zombies:polevault\": 3\r\n    },\r\n    {\r\n      \"zombies:buckethead\": 10,\r\n      \"zombies:conehead\": 22,\r\n      \"zombies:basic\": 25,\r\n      \"zombies:polevault\": 5\r\n    }\r\n\r\n  ],\r\n  \"roam_zombies\": {\r\n    \"zombies:basic\": 35,\r\n    \"zombies:conehead\": 12,\r\n    \"zombies:buckethead\": 7,\r\n    \"zombies:polevault\": 8\r\n  }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- data/locations/day/3/data.json	(revision 1e716dbc123e95b1d68c78e817188db88446aa38)
+++ data/locations/day/3/data.json	(date 1621304892290)
@@ -19,9 +19,9 @@
 
   ],
   "roam_zombies": {
-    "zombies:basic": 35,
-    "zombies:conehead": 12,
-    "zombies:buckethead": 7,
-    "zombies:polevault": 8
+    "zombies:basic": 15,
+    "zombies:conehead": 8,
+    "zombies:buckethead": 2,
+    "zombies:polevault": 2
   }
 }
\ No newline at end of file
